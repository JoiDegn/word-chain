#!/usr/bin/env python3

"""
Author: Johannes Degn <j@degn.de>
 This script uses the recursive function permutation in order to find the end value
 starting with a start value
"""

import optparse
import sys

usage = "usage: wordchains -d <dictionary file>"
parser = optparse.OptionParser(usage)
parser.add_option("-d", "--dictionary", help="Dictionary file to use", default="/usr/share/dict/words")
(options, args) = parser.parse_args()
# load dictionary in set
dict_file = open(options.dictionary, 'r')
dictionary = set(dict_file.read().lower().split())
print('dictionary file loaded: %d  entries' % len(dictionary)) 




def main():
  r = ''
  while True:
    print('waiting for input...')
    r = sys.stdin.readline().lower()
    if r in ['exit\n', 'quit\n', 'stop\n', 'let me out\n']:
      break

    r = r.split()
    if (len(r) % 2 != 0) or (len(r) == 0): # we need at start least one start and one end value
      print ('\nexpected input: <startword> <endword> [<startword2> <endword2> ...] \n please enter pairs of words')
      continue

    # we have received at least one pair of words

    while r:
      end, start = r.pop(), r.pop()
      print (start, end)
      result = wordchain(start, end)
      print(repr(result))

def wordchain(startvalue, endvalue, checked = set()):
  #print (startvalue, endvalue, checked)
  mutations = getmutations(startvalue)
  checked.add(startvalue)
  if endvalue in mutations:  # we found the endvalue
    checked.add(endvalue)
    return checked
  else:
    for new_start in mutations:   
      if not new_start in checked: # make sure we dont double check words
        return wordchain(new_start, endvalue, checked)

def getmutations(word):  # checks dictionary for permutations of word
  mutations = set()
  for dict_word in dictionary:
    if ismutation(word, dict_word):
      mutations.add(dict_word)
  #print ('mutations of %s: %s\n\n\n' % (word, mutations)) 
  return mutations

def ismutation(word1, word2):
  print ('\n\nchecking: %s vs %s' % (word1 , word2))
  diff = abs(len(word1)-len(word2)) 
  if diff > 1:  
    print ('len diff to big %d' % diff)
    return False  # shortcut
  elif diff == 1:
    if not (word1.find(word2) or word2.find(word1)): # make sure one word is substring of the other
      print ('no fucking substring')
      return False
  elif diff == 0: # if size is the same
    diff += check_letters(word1, word2)
  else:
    return False
  print (diff)
  return diff < 2 

def check_letters(word1, word2): # hamming distance, word1 and word2 need to be of same length
  diff = 0
  return sum(letter1!=letter2 for letter1, letter2 in zip(word1, word2))


if __name__ == "__main__":
  res = getmutations('hello')
  main()
